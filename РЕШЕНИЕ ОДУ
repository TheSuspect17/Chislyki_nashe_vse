import matplotlib.pyplot as plt
import math
import numpy as np
from matrix import method_min_square, newton_here_the_boss
from sympy import symbols, lambdify, sqrt, cos, sin, log, exp

HS = 0.01     #Константы 
HF = 1.01 
HH = 0.01
X0 = 0
Y0 = 1
XF = 100
answer = '0'

class Exact:
    def __init__(self, solved_equation, h):
        self.f = solved_equation
        self.h = h

    def _next_y(self, xi, yi):
        return self.f(xi)

    def calculate(self, x0, y0, xf):
        ys = []
        xs = np.arange(x0 + self.h, xf + self.h, self.h)  # вектор всех значений x
        y = y0
        for x in xs:
            ys.append(y)
            y = self._next_y(x, y)
        return ys

class Euler(Exact):
    def _next_y(self, xi, yi):
        return yi + self.h * self.f(xi, yi)

class ImprovedEuler(Euler):
    def _next_y(self, xi, yi):
        h2 = self.h / 2
        delta_y = self.h * self.f(xi + h2, yi + h2 * self.f(xi, yi))
        return yi + delta_y
    
def input_function():
    t = symbols('t')
    y = symbols('y')
    z = symbols('z')
    equation = []

    qwe = eval(input('Введите y` [доступные символы t,y,z]: '))
    equation.append(qwe)
    global answer
    answer = input('Хотите ввести еще одно уравнение? [1/0] ')
    if answer == '1':
        qwe = eval(input('Введите z` [доступные символы t,y,z]: '))
        equation.append(qwe)
    function = []
    for i in range(len(equation)):
        function.append(lambdify([t, y, z], equation[i]))
    return function

def rungekutta4(function):
    y0 = float(input('Начальное условие, y0 = '))
    if answer == '1':
        z0 = float(input('Начальное условие, z0 = '))
        zn = z0
    a = float(input('Начало промежутка: '))
    b = float(input('Конец промежутка: '))
    n = 100
    h = (b - a) / n
    output = [[0, 0, y0]]
    counter = 0
    yn = y0
    otrezok = []
    for i in range(n):
        a += h
        otrezok.append(round(a, 5))
    if answer == '0':
        for i in otrezok:
            counter += 1
            k1 = function[0](i, yn,1) * h
            k2 = function[0](i + h / 2, yn + k1 / 2, 1) * h
            k3 = function[0](i + h / 2, yn + k2 / 2, 1) * h
            k4 = function[0](i + h, yn + k3, 1) * h
            yn = yn + (1 / 6) * (k1 + 2 * k2 + 3 * k3 + k4)
            output.append([counter, i, yn])
        return output
    elif answer == '1':
        output = [[0, 0, y0, z0]]
        for i in otrezok:
            counter += 1
            k1 = function[0](i, yn, zn) * h
            m1 = function[1](i, yn, zn) * h

            k2 = function[0](i + h / 2, yn + k1 / 2, zn + m1 / 2) * h
            m2 = function[1](i + h / 2, yn + k1 / 2, zn + m1 / 2) * h

            k3 = function[0](i + h / 2, yn + k2 / 2, zn + m2 / 2) * h
            m3 = function[1](i + h / 2, yn + k2 / 2, zn + m2 / 2) * h

            k4 = function[0](i + h, yn + k3, zn + m3) * h
            m4 = function[1](i + h, yn + k3, zn + m3) * h

            yn = yn + (1 / 6) * (k1 + 2 * k2 + 3 * k3 + k4)
            zn = zn + (1 / 6) * (m1 + 2 * m2 + 3 * m3 + m4)
            output.append([counter, i, yn, zn])
        return output


plt.style.use('ggplot')    
    
def draw(x0, xf, h, labels, *args):
    assert len(labels) == len(args)
    xs = np.arange(x0, xf, h)
    for (i, ys) in enumerate(args):
        plt.plot(xs, ys, label=labels[i], linewidth=1)
        plt.xlabel('X')
        plt.ylabel('Y')
        plt.title("Result")
        plt.legend()
        plt.show()
        return (xs, ys)

def func(x, y):
    return math.exp(-x) - y

def equation(x, y):
    return   (math.exp(-x)-y) #ВВОД С КЛАВИАТУРЫ

def solved_equation(x):
    return ((x+C)/math.exp(x) ) 

def calculate_error(ys_approx, ys_exact):
    return [abs(y1 - y2) for y1, y2 in zip(ys_approx, ys_exact)]

def calculate_mean_error(ys_approx, ys_exact):
    return sum(calculate_error(ys_approx, ys_exact))/len(ys_exact)

if __name__ == '__main__':
    euler_error = []
    better_euler_error = []
    rk_error = []

    h_axis = np.arange(HS, HF, HH)
    for H in h_axis:
        exact = Exact(solved_equation, H)
        exact_ys = exact.calculate(X0, Y0, XF)
        euler = Euler(equation, H)
        euler_ys = euler.calculate(X0, Y0, XF)
        better_euler = ImprovedEuler(equation, H)
        b_euler_ys = better_euler.calculate(X0, Y0, XF)
        euler_error.append(calculate_mean_error(euler_ys, exact_ys))
        better_euler_error.append(calculate_mean_error(b_euler_ys, exact_ys))

    X1,Y1 = draw(HS, HF, HH, ['Euler'], euler_error)
    X2,Y2 = draw(HS, HF, HH, ['Impr Euler'], better_euler_error)
noname = method_min_square(X1,Y1)
straight = noname[1]
_ = noname[0]
gamma = round(noname[2],3)
x_square = []
f_square = []
for i in range(len(X1)):
    x_square.append(_[i][0])
    f_square.append(_[i][2])

plt.plot(x_square, f_square, 'r', label=f'Интерполированная функция c G = {gamma}')
plt.title("МНК Элером ")
plt.legend(loc='best', prop={'size': 8}, frameon = False)
plt.show()

noname = newton_here_the_boss(X1,Y1)
straight = noname[1]
x1_square = []
f1_square = []
for i in range(len(noname[1])):
    x1_square.append(noname[0][i])
    f1_square.append(noname[1][i])
plt.plot(x1_square, f1_square, 'r', label=f'Ньютон')
plt.title("Интерполяция Ньтоном Эйлера ")
plt.legend(loc='best', prop={'size': 8}, frameon = False)
plt.show()

noname = method_min_square(X2,Y2)
straight = noname[1]
_ = noname[0]
gamma = round(noname[2],3)
x_square = []
f_square = []
for i in range(len(X2)):
    x_square.append(_[i][0])
    f_square.append(_[i][2])

plt.plot(x_square, f_square, 'r', label=f'Интерполированная функция  = {gamma}')
plt.title("МНК Элером Коши")
plt.legend(loc='best', prop={'size': 8}, frameon = False)
plt.show()

noname = newton_here_the_boss(X2,Y2)
straight = noname[1]
x1_square = []
f1_square = []
for i in range(len(noname[1])):
    x1_square.append(noname[0][i])
    f1_square.append(noname[1][i])
plt.plot(x1_square, f1_square, 'r', label=f'Ньютон')
plt.title("Интерполяция Ньтоном Эйлера-Коши")
plt.legend(loc='best', prop={'size': 8}, frameon = False)
plt.show()


x = []
y = []
z = []

noname = rungekutta4(input_function())
for i in range(len(noname)):
    x.append(noname[i][1])
    y.append(noname[i][2])
    if answer == '1':
        z.append(noname[i][3])




plt.plot(x, y, label='Выходные точки Рунге-Кутты функции y(t)')
if answer == '1':
    plt.plot(x, z, label='Выходные точки Рунге-Кутты функции z(t)')
plt.title("Выходные точки метода Рунге-Кутты")

plt.legend(loc='best', prop={'size': 8}, frameon=False)

plt.show()

noname = method_min_square(x, y)
_ = noname[0]
if answer == "1":
    nonamez = method_min_square(x,z)
    _z = nonamez[0]
    gamma_z = round(nonamez[2], 3)
gamma_y = round(noname[2], 3)
x_square = []
y_square = []
z_square = []
for i in range(len(x)):
    x_square.append(_[i][0])
    y_square.append(_[i][2])
    if answer == '1':
        z_square.append(_z[i][2])


plt.plot(x_square, y_square, 'r', label=f'МНК y(t) c G = {gamma_y}')
if answer == '1':
    plt.plot(x_square, z_square, 'b', label=f'МНК z(t) c G = {gamma_z}')
plt.title("МНК")
plt.legend(loc='best', prop={'size': 8}, frameon=False)

plt.show()

noname = newton_here_the_boss(x, y)
if answer == '1':
    nonamez = newton_here_the_boss(x,z)
x1_square = []
f1_square = []
z_square = []
for i in range(len(noname[1])):
    x1_square.append(noname[0][i])
    f1_square.append(noname[1][i])
    if answer == '1':
        z_square.append(nonamez[1][i])
plt.plot(x1_square, f1_square, 'r', label=f'Ньютон y')
if answer == '1':
    plt.plot(x1_square, z_square, 'b', label=f'Ньютон z')
plt.title("Ньютон")
plt.legend(loc='best', prop={'size': 8}, frameon=False)

plt.show()

